[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Physics",
    "section": "",
    "text": "Preface\nI first learned to program in 2011 in Dr. Richard O. Gray’s computational physics course.\nIt was a revelatory experience that shaped my life. I enjoyed the class so much that I served as the TA the following year and later earned a PhD in Computational Science.\nI’ve kept the lecture notes on my various computers ever since. Rather than posting the original notes unchanged, I’m converting them into a Quarto book, updating examples from C to Python and adding some of my own material.\nNote: Most of the content and examples are taken from Dr. Gray’s original course materials.\n\n\nColophon\nThis is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\nTo learn more about Quarto books, visit https://quarto.org/docs/books\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "04-interpolation.html",
    "href": "04-interpolation.html",
    "title": "1  Interpolation",
    "section": "",
    "text": "1.1 Linear Interpolation\nA common computational problem in physics involves determining the value of a particular function at one or more points of interest from a tabulation of that function. For instance, we may wish to calculate the index of refraction of a type of glass at a particular wavelength, but be faced with the problem that that particular wavelength is not explicitly in the tabulation. In such cases, we need to be able to interpolate in the table to find the value of the function at the point of interest. Let us take a particular example.\nBK-7 is a type of common optical crown glass. Its index of refraction \\(n\\) varies as a function of wavelength; for shorter wavelengths \\(n\\) is larger than for longer wavelengths, and thus violet light is refracted more strongly than red light, leading to the phenomenon of dispersion. The index of refraction is tabulated in Table 1.1.\nLet us suppose that we wish to find the index of refraction at a wavelength of \\(5000Å\\). Unfortunately, that wavelength is not found in the table, and so we must estimate it from the values in the table. We must make some assumption about how \\(n\\) varies between the tabular values. Presumably it varies in a smooth sort of way and does not take wild excursions between the tabulated values. The simplest and quite often an entirely adequate assumption to make is that the actual function varies linearly between the tabulated values. This is the basis of linear interpolation.\nHow do we carry out linear interpolation on the computer? Let us suppose that the function is tabulated at \\(N\\) points and takes on the values \\(y_1,y_2,y_3 ...\ny_N\\) at the points \\(x_1,x_2,x_3 ... x_N\\), and that we want to find the value of the function \\(y\\) at a point \\(x\\) that lies someplace in the interval between \\(x_1\\) and \\(x_N\\).\nThe first thing that we must do is to bracket \\(x\\), that is we must find a \\(j\\) such that \\(x_j &lt; x \\leq x_{j+1}\\). This can be accomplished by the following code fragment:\nwhere the xn’s are the tabulated points. When the if statement is satisfied, j is assigned the value of i and the procedure drops out of the loop. Please note that this is not the most efficient way to accomplish this task, especially if \\(N\\) is very large. We will look at a more efficient way later on.\nOnce we have bracketed \\(x\\), we can find the equation of the line between the points \\((x_j,y_j)\\) and \\((x_{j+1},y_{j+1})\\). This equation will be of the form \\(y = mx+b4 where\\)m$ is the slope and \\(b\\) is the y-intercept. As we all know, the slope is given by\n\\[\nm = \\frac{y_{j+1}-y_j}{x_{j+1}-x_j}\n\\]\nand the intercept can be found by substituting one point, say, \\((x_j,y_j)\\) into the resulting equation. Thus,\n\\[\nb=y-mx=y_j-\\frac{y_{j+1}-y_j}{x_{j+1}-x_j}x_j\n\\]\nyielding for the equation of the line, after some rearrangement,\n\\[\ny==y_j+\\left(\\frac{y_{j+1}-y_j}{x_{j+1}-x_j}\\right)(x-x_j)\n\\]\nIt is left to the student to show (for future reference) that this equation may be rewritten \\[\ny=Ay_j+By_{j+1}\n\\] where \\[\nA = \\frac{x_{j+1}-x}{x_{j+1}-x_j}\n\\] and \\[\nB = \\frac{x-x_j}{x_{j+1}-x_j}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Interpolation</span>"
    ]
  },
  {
    "objectID": "04-interpolation.html#linear-interpolation",
    "href": "04-interpolation.html#linear-interpolation",
    "title": "1  Interpolation",
    "section": "",
    "text": "Table 1.1: Refractive Index for BK7 Glass\n\n\n\n\n\n\n\n\\(\\lambda (Å)\\)\n\\(n\\)\n\n\n\n\n3511\n1.53894\n\n\n3638\n1.53648\n\n\n4047\n1.53024\n\n\n4358\n1.52669\n\n\n4416\n1.52611\n\n\n4579\n1.52462\n\n\n4658\n1.52395\n\n\n4727\n1.52339\n\n\n4765\n1.5231\n\n\n4800\n1.52283\n\n\n4861\n1.52238\n\n\n4880\n1.52224\n\n\n\n\n\n\n\n\n\\(\\lambda (Å)\\)\n\\(n\\)\n\n\n\n\n4965\n1.52165\n\n\n5017\n1.5213\n\n\n5145\n1.52049\n\n\n5320\n1.51947\n\n\n5461\n1.51872\n\n\n5876\n1.5168\n\n\n5893\n1.51673\n\n\n6328\n1.51509\n\n\n6438\n1.51472\n\n\n6563\n1.51432\n\n\n6943\n1.51322\n\n\n7860\n1.51106\n\n\n\n\n\n\n\n\n\\(\\lambda (Å)\\)\n\\(n\\)\n\n\n\n\n8210\n1.51037\n\n\n8300\n1.51021\n\n\n8521\n1.50981\n\n\n9040\n1.50894\n\n\n10140\n1.50731\n\n\n10600\n1.50669\n\n\n13000\n1.50371\n\n\n15000\n1.5013\n\n\n15500\n1.50068\n\n\n19701\n1.495\n\n\n23254\n1.48929\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteExercise 4.1\n\n\n\nDetermine, by hand, the value of the index of refraction of BK7 at \\(5000Å\\) using linear interpolation.\n\n\n\n\nfor(i=1;i&lt;N;i++) {\n    if(xn[i] &lt; x && xn[i+1] &gt;= x) {\n        j = i;\n        break; \n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteExercise 4.2\n\n\n\nWrite a C-function that will linearly interpolate the tabular data for the index of refraction of BK-7 and return a value for \\(n\\) for wavelengths between \\(3511Å\\) and \\(23254Å\\). Write a driver program that will use this function to prompt the user for a wavelength and then print to screen the corresponding value of \\(n\\).\n\n\n\n\n\n\n\n\nNoteExercise 4.3\n\n\n\nThe file data/boiling.dat contains data in two columns for the boiling point of water at different atmospheric pressures. The first column is the pressure in millibars, the second is the corresponding boiling point temperature in degrees Celsius. Write a C-function that initializes two vectors, P and T with the data in that data file (don’t read in the datafile – hardwire the data into your program), accepts the pressure as a double floating-point parameter, and returns the value of the temperature of the boiling point at that pressure. You should also write a driver program that will prompt the user for an atmospheric pressure, check whether it is within the limits of the data \\((50 ≤ P ≤ 2150)\\), calls your C-function, and prints to the screen the boiling point of water at that pressure.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Interpolation</span>"
    ]
  },
  {
    "objectID": "04-interpolation.html#polynomial-interpolation",
    "href": "04-interpolation.html#polynomial-interpolation",
    "title": "1  Interpolation",
    "section": "1.2 Polynomial Interpolation",
    "text": "1.2 Polynomial Interpolation\nLinear interpolation is good enough for government work, and it is even better than that. Because it is simple and makes the simplest possible assumption about the data, it should be employed in all cases except where it is manifestly inadequate. There are such cases. Sometimes the function being interpolated is very non-linear or has been tabulated at such wide intervals that linear interpolation would lead to large errors. Some applications demand more than simply the functional values at the interpolated points; sometimes the derivative of the function is required as well. With linear interpolation, the derivative is a constant between the tabulated points, and may actually be undefined at the tabulated points!\nFor such applications it may be best to interpolate using a polynomial interpolating function or functions. It can be shown that the following poly- nomial \\(P(x)\\) of degree \\(N−1\\) will exactly pass through the N tabulated points of the function \\(y = f(x)\\):\n\\[\\begin{align*}\nP(x) =\\;&\n\\frac{(x - x_2)(x - x_3)\\cdots(x - x_N)}\n     {(x_1 - x_2)(x_1 - x_3)\\cdots(x_1 - x_N)}\\,y_1 \\\\[1em]\n&+ \\frac{(x - x_1)(x - x_3)\\cdots(x - x_N)}\n     {(x_2 - x_1)(x_2 - x_3)\\cdots(x_2 - x_N)}\\,y_2 \\\\[1em]\n&+ \\cdots \\\\[1em]\n&+ \\frac{(x - x_1)(x - x_2)\\cdots(x - x_{N-1})}\n     {(x_N - x_1)(x_N - x_2)\\cdots(x_N - x_{N-1})}\\,y_N\n\\end{align*}\\]\nThe problem with the direct application of the polynomial \\(P(x)\\) is that for tabulations with many points, it can lead to very high degree polynomials. For instance, if a function is tabulated at 100 points, the above equation would yield a polynomial of degree 99! Such a polynomial could potentially fluctuate wildly between the tabulated points and thus not be a good representation of the actual function. \\(P(x)\\) is more usually applied to subsets of the tabulated points. For instance, if the polynomial is applied to subsets of 3 points, it yields parabolic interpolation, which can be much superior to linear interpolation if the function has a number of minima and maxima.\nOne problem with parabolic 3-point interpolation is that when it comes to bracketing \\(x\\), there is an ambiguity – does one bracket between \\(x_1\\) and \\(x_2\\) or between \\(x_2\\) and \\(x_3\\)? This is one reason why cubic 4-point interpolation is more commonly practiced – the bracketing is then between \\(x_2\\) and \\(x_3\\) with no ambiguity. Such interpolation is also called Lagrangian 4-point interpolation. The Lagrangian 4-point interpolation equation can be written:\n\\[\\begin{align*}\nL(x) =\\;&\n\\frac{(x - x_2)(x - x_3)(x - x_4)}\n     {(x_1 - x_2)(x_1 - x_3)(x_1 - x_4)}\\,y_1 \\\\[1em]\n&+ \\frac{(x - x_1)(x - x_3)(x - x_4)}\n     {(x_2 - x_1)(x_2 - x_3)(x_2 - x_4)}\\,y_2 \\\\[1em]\n&+ \\frac{(x - x_1)(x - x_2)(x - x_4)}\n     {(x_3 - x_1)(x_3 - x_2)(x_3 - x_4)}\\,y_3 \\\\[1em]\n&+ \\frac{(x - x_1)(x - x_2)(x - x_3)}\n     {(x_4 - x_1)(x_4 - x_2)(x_4 - x_3)}\\,y_4\n\\end{align*}\\]\nwhich the student can easily verify by reference to the equation for \\(P(x)\\).\nTo apply this interpolation equation, the user should first bracket \\(x\\) between \\(x_j\\) and \\(x_{j+1}\\) as before, but now identify \\(x_j\\) with \\(x_2\\) in the above equation and \\(x_{j+1}\\) with \\(x_3\\). It then follows that \\(x_1\\) will be \\(x_{j−1}\\) and \\(x_4\\) will be \\(x_{j+2}\\). The perceptive student will see that this will lead to a problem at the endpoints. For instance, if \\(x\\) is situated between the first two tabulated points, \\(x_{j−1}\\) will be undefined. Likewise, if \\(x\\) is situated between the last two tabulated points, \\(x_{j+2}\\) will be undefined. Thus in those intervals, the user must either interpolate linearly, or, in the first case, use the polynomial that would be used for an \\(x\\) bracketed between the 2nd and 3rd tabulated points, and similarly for the last case.\n\n\n\n\n\n\nNoteExercise 4.4\n\n\n\nWrite a C-function that will implement the 4-point Lagrangian interpolation formula above. For the endpoints, use the polynomial that would have been defined for the adjacent interval as described above. Modify the driver program in Exercise 4.2 (interpolation in a table of the wavelength and the index of refraction for BK-7 glass) to use this new C-function. Compare the results between the two programs.\n\n\n\n\n\n\n\n\nNoteExercise 4.5\n\n\n\nWrite a C-function that will implement the 4-point Lagrangian interpolation formula above. For the endpoints, use the polynomial that would have been defined for the adjacent interval as described above. Modify the driver program in Exercise 4.3 (interpolation in a table of atmospheric pressure and the boiling point of water) to use this new C-function. Compare the results between the two programs.\n\n\nWe have only scratched the surface of the subject of interpolation. The subject of Extrapolation – finding a value for a function outside the range of the defined points – is much more dangerous. Interpolation schemes can be used for extrapolation, but only with great care!\nBefore we leave the subject of interpolation, let us examine one further subject, that of efficiently bracketing \\(x\\). If we have a set of \\(x\\)’s (say in a vector x[i]) in numerical order that we must find interpolated values for, there is a simple time saving step that we can use, implemented in the following fragment of code (assume x is a vector of dimension n):\nj = 1;\nfor(k=1;k&lt;=n;k++) { \n    for(i=j;i&lt;N;i++) {\n        if(xn[i] &lt; x[k] && xn[i+1] &gt;= x[k]) { \n            j = i;\n            break; \n        }\n    }\n    here is your interpolation function code \n}\nNotice that the second for loop begins at i=j and not i=1; since the \\(x_k\\)’s are in numerical order, if \\(x_k\\) is bracketed between xn[j] and xn[j+1], there is no need to search beginning at i=1 for \\(x_{k+1}\\) because it will either be bracketed between the same pair or later pairs (note that we are obviously also assuming that the xn[j]’s are in numerical order). This can save an enormous amount of time in a code that needs to interpolate in a large (say \\(N &gt; 100\\)) table. Another useful trick is that of bisection. Further notes on bisection and other techniques for efficiently bracketing \\(x\\) can be found in Numerical Recipes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Interpolation</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  }
]